LittleEndian();
DisplayFormatHex();

local uint32 i, rom_file_entry_count;
local uint64 fs_offset;

typedef struct {
	uint32 entry_point;
	uint32 mod_offset;
} RoCrt;

struct {
	RoCrt ro_crt;
	char  reserved_1[0x8];
} mod_start;

typedef struct {
	uint32 memory_offset;
	uint32 size;
} SegmentHeader;

typedef struct {
	uint32 offset;
	uint32 size;
} SectionHeader;

struct {
	char   magic[0x4];
	uint32 version;
	uint32 size;
	uint32 flags;
	SegmentHeader text_segment_header;
	SegmentHeader ro_segment_header;
	SegmentHeader data_segment_header;
	uint32 bss_size;
	uint32 reserved_1;
	ubyte  module_id[0x20];
	uint32 dso_handle_offset;
	uint32 reserved_2;
	SectionHeader embedded_section_header; /* api_info */
	SectionHeader dyn_str_section_header;
	SectionHeader dyn_sym_section_header;
} nro_header;

typedef struct {
	char   magic[0x4];
	uint32 dynamic_offset;
	uint32 bss_start_offset;
	uint32 bss_end_offset;
	uint32 eh_frame_hdr_start_offset;
	uint32 eh_frame_hdr_end_offset;
	uint32 module_object_offset;
} ModHeader;

typedef struct {
	char   magic[0x4];
	uint32 got_start_offset;
	uint32 got_end_offset;
} LnyHeader;

FSeek(0x0);
struct {
	ubyte text_segment[nro_header.text_segment_header.size];
	ubyte ro_segment[nro_header.ro_segment_header.size];
	ubyte data_segment[nro_header.data_segment_header.size];
	FSeek(mod_start.ro_crt.mod_offset);
	ModHeader mod_header;
	if (mod_start.reserved_1 == "HOMEBREW") {
		LnyHeader lny_header;
	}
	FSeek(startof(ro_segment) + nro_header.embedded_section_header.offset);
	ubyte embedded_section[nro_header.embedded_section_header.size];
	FSeek(startof(ro_segment) + nro_header.dyn_str_section_header.offset);
	ubyte dyn_str_section[nro_header.dyn_str_section_header.size];
	FSeek(startof(ro_segment) + nro_header.dyn_sym_section_header.offset);
	ubyte dyn_sym_section[nro_header.dyn_sym_section_header.size];
} nro_body;

if (mod_start.reserved_1 == "HOMEBREW") {
	typedef struct {
		uint64 offset;
		uint64 size;
	} AsetSectionHeader;
	
	FSeek(nro_header.size);
	struct {
		char   magic[0x4];
		uint32 version;
		AsetSectionHeader icon_section_header;
		AsetSectionHeader nacp_section_header;
		AsetSectionHeader romfs_section_header;
	} aset_header;

	typedef struct {
		ubyte name[0x200];
		ubyte publisher[0x100];
	} Title;

	typedef enum <ubyte> {
		StartupUserAccount_None                                       = 0,
		StartupUserAccount_Required                                   = 1,
		StartupUserAccount_RequiredWithNetworkServiceAccountAvailable = 2
	} StartupUserAccount;

	typedef enum <ubyte> {
		UserAccountSwitchLock_Disable = 0,
		UserAccountSwitchLock_Enable  = 1
	} UserAccountSwitchLock;

	typedef enum <ubyte> {
		AddOnContentRegistrationType_AllOnLaunch = 0,
		AddOnContentRegistrationType_OnDemand    = 1
	} AddOnContentRegistrationType;

	typedef struct {
		uint32 AttributeFlag_Demo                     : 1;
		uint32 AttributeFlag_RetailInteractiveDisplay : 1;
	} AttributeFlag;

	typedef struct {
		uint32 SupportedLanguageFlag_AmericanEnglish      : 1;
		uint32 SupportedLanguageFlag_BritishEnglish       : 1;
		uint32 SupportedLanguageFlag_Japanese             : 1;
		uint32 SupportedLanguageFlag_French               : 1;
		uint32 SupportedLanguageFlag_German               : 1;
		uint32 SupportedLanguageFlag_LatinAmericanSpanish : 1;
		uint32 SupportedLanguageFlag_Spanish              : 1;
		uint32 SupportedLanguageFlag_Italian              : 1;
		uint32 SupportedLanguageFlag_Dutch                : 1;
		uint32 SupportedLanguageFlag_CanadianFrench       : 1;
		uint32 SupportedLanguageFlag_Portuguese           : 1;
		uint32 SupportedLanguageFlag_Russian              : 1;
		uint32 SupportedLanguageFlag_Korean               : 1;
		uint32 SupportedLanguageFlag_TraditionalChinese   : 1;
		uint32 SupportedLanguageFlag_SimplifiedChinese    : 1;
	} SupportedLanguageFlag;

	typedef struct {
		uint32 ParentalControlFlag_FreeCommunication : 1;
	} ParentalControlFlag;

	typedef enum <ubyte> {
		Screenshot_Allow = 0,
		Screenshot_Deny  = 1
	} Screenshot;

	typedef enum <ubyte> {
		VideoCapture_Disable = 0,
		VideoCapture_Manual  = 1,
		VideoCapture_Enable  = 2
	} VideoCapture;

	typedef enum <ubyte> {
		DataLossConfirmation_None     = 0,
		DataLossConfirmation_Required = 1
	} DataLossConfirmation;

	typedef enum <ubyte> {
		PlayLogPolicy_All     = 0,
		PlayLogPolicy_LogOnly = 1,
		PlayLogPolicy_None    = 2
	} PlayLogPolicy;

	typedef struct {
		ubyte cero;
		ubyte gracgcrb;
		ubyte gsrmr;
		ubyte esrb;
		ubyte class_ind;
		ubyte usk;
		ubyte pegi;
		ubyte pegi_portugal;
		ubyte pegibbfc;
		ubyte russian;
		ubyte acb;
		ubyte oflc;
		ubyte iarc_generic;
		ubyte reserved_1[0x13];
	} RatingAge;

	typedef enum <ubyte> {
		LogoType_LicensedByNintendo    = 0,
		LogoType_DistributedByNintendo = 1, /* Removed? */
		LogoType_Nintendo              = 2
	} LogoType;

	typedef enum <ubyte> {
		LogoHandling_Auto   = 0,
		LogoHandling_Manual = 1
	} LogoHandling;

	typedef enum <ubyte> {
		RuntimeAddOnContentInstall_Deny        = 0,
		RuntimeAddOnContentInstall_AllowAppend = 1
	} RuntimeAddOnContentInstall;

	typedef enum <ubyte> {
		RuntimeParameterDelivery_Always                   = 0,
		RuntimeParameterDelivery_AlwaysIfUserStateMatched = 1,
		RuntimeParameterDelivery_OnRestart                = 2
	} RuntimeParameterDelivery;

	typedef enum <ubyte> {
		CrashReport_Deny  = 0,
		CrashReport_Allow = 1
	} CrashReport;

	typedef enum <ubyte> {
		Hdcp_None     = 0,
		Hdcp_Required = 1
	} Hdcp;

	typedef struct {
		ubyte StartupUserAccountOption_IsOptional : 1;
	} StartupUserAccountOption;

	typedef enum <ubyte> {
		PlayLogQueryCapability_None      = 0,
		PlayLogQueryCapability_WhiteList = 1,
		PlayLogQueryCapability_All       = 2
	} PlayLogQueryCapability;

	typedef struct {
		ubyte RepairFlag_SuppressGameCardAccess : 1;
	} RepairFlag;

	typedef struct {
		ubyte RequiredNetworkServiceLicenseOnLaunchFlag_Common : 1;
	} RequiredNetworkServiceLicenseOnLaunchFlag;

	typedef struct {
		uint64 group_id;
		ubyte  key[0x10];
	} NeighborDetectionGroupConfiguration;

	typedef struct {
		NeighborDetectionGroupConfiguration send_group_configuration;
		NeighborDetectionGroupConfiguration receivable_group_configurations[0x10];
	} NeighborDetectionClientConfiguration;

	typedef enum <uint64> {
		JitConfigurationFlag_None    = 0,
		JitConfigurationFlag_Enabled = 1
	} JitConfigurationFlag;

	typedef struct {
		JitConfigurationFlag jit_configuration_flag;
		uint64 memory_size;
	} JitConfiguration;

	typedef struct {
		Title  titles[0x10];
		char   isbn[0x25];
		StartupUserAccount startup_user_account;
		UserAccountSwitchLock user_account_switch_lock; /* Old: touch_screen_usage (None, Supported, Required) */
		AddOnContentRegistrationType add_on_content_registration_type;
		AttributeFlag attribute_flag;
		SupportedLanguageFlag supported_language_flag;
		ParentalControlFlag parental_control_flag;
		Screenshot screenshot;
		VideoCapture video_capture;
		DataLossConfirmation data_loss_confirmation;
		PlayLogPolicy play_log_policy;
		uint64 presence_group_id;
		RatingAge rating_ages;
		char   display_version[0x10];
		uint64 add_on_content_base_id;
		uint64 save_data_owner_id;
		uint64 user_account_save_data_size;
		uint64 user_account_save_data_journal_size;
		uint64 device_save_data_size;
		uint64 device_save_data_journal_size;
		uint64 bcat_delivery_cache_storage_size;
		char   application_error_code_category[0x8];
		uint64 local_communication_ids[0x8];
		LogoType logo_type;
		LogoHandling logo_handling;
		RuntimeAddOnContentInstall runtime_add_on_content_install;
		RuntimeParameterDelivery runtime_parameter_delivery;
		ubyte  reserved_1[0x2];
		CrashReport crash_report;
		Hdcp   hdcp;
		uint64 seed_for_pseudo_device_id;
		char   bcat_passphrase[0x41];
		StartupUserAccountOption startup_user_account_option;
		ubyte  reserved_2[0x6];
		uint64 user_account_save_data_size_max;
		uint64 user_account_save_data_journal_size_max;
		uint64 device_save_data_size_max;
		uint64 device_save_data_journal_size_max;
		uint64 temporary_storage_size;
		uint64 cache_storage_size;
		uint64 cache_storage_journal_size;
		uint64 cache_storage_data_and_journal_size_max;
		uint16 cache_storage_index_max;
		ubyte  reserved_3[0x6];
		uint64 play_log_queryable_application_ids[0x10];
		PlayLogQueryCapability play_log_query_capability;
		RepairFlag repair_flag;
		ubyte  program_index;
		RequiredNetworkServiceLicenseOnLaunchFlag required_network_service_license_on_launch_flag;
		uint32 reserved_4;
		NeighborDetectionClientConfiguration neighbor_detection_client_configuration;
		JitConfiguration jit_configuration;
		ubyte  reserved_5[0xC40];
	} Nacp;
	
	typedef struct {
		uint64 header_size;
		uint64 directory_bucket_offset;
		uint64 directory_bucket_size;
		uint64 directory_entry_offset;
		uint64 directory_entry_size;
		uint64 file_bucket_offset;
		uint64 file_bucket_size;
		uint64 file_entry_offset;
		uint64 file_entry_size;
		uint64 body_offset;
	} RomFileSystemInformation;
	
	typedef struct {
		uint32 parent_offset;
		uint32 next_offset;
		uint32 directory_offset;
		uint32 file_offset;
		uint32 hash_offset;
		uint32 name_length;
		char   name[name_length];
		ubyte  reserved_1[(name_length + 0x1B & -0x4) - (0x18 + name_length)];
	} RomDirectoryEntry;
	
	typedef struct {
		uint32 parent_offset;
		uint32 next_offset;
		uint64 offset;
		uint64 size;
		uint32 hash_offset;
		uint32 name_length;
		char   name[name_length];
		ubyte  reserved_1[(name_length + 0x23 & -0x4) - (0x20 + name_length)];
	} RomFileEntry;
	
	typedef struct {
		ubyte data[rom_file_entry[i].size];
	} RomFileData;
	
	typedef struct {
		fs_offset = nro_header.size + aset_header.romfs_section_header.offset;
		RomFileSystemInformation rom_file_system_information;
		FSeek(fs_offset + rom_file_system_information.directory_bucket_offset);
		uint32 rom_directory_buckets[rom_file_system_information.directory_bucket_size / 0x4];
		FSeek(fs_offset + rom_file_system_information.directory_entry_offset);
		while (FTell() < (fs_offset + rom_file_system_information.directory_entry_offset + rom_file_system_information.directory_entry_size)) {
			RomDirectoryEntry rom_directory_entry;
		}
		FSeek(fs_offset + rom_file_system_information.file_bucket_offset);
		uint32 rom_file_buckets[rom_file_system_information.file_bucket_size / 0x4];
		FSeek(fs_offset + rom_file_system_information.file_entry_offset);
		while (FTell() < (fs_offset + rom_file_system_information.file_entry_offset + rom_file_system_information.file_entry_size)) {
			RomFileEntry rom_file_entry;
			rom_file_entry_count++;
		}
		for (i = 0; i < rom_file_entry_count; i++) {
			FSeek(fs_offset + rom_file_system_information.body_offset + rom_file_entry[i].offset);
			RomFileData rom_file_data;
		}
	} RomFileSystem;
	
	struct {
		ubyte icon[aset_header.icon_section_header.size];
		Nacp  nacp;
		if (aset_header.romfs_section_header.size != 0) {
			RomFileSystem rom_file_system;
		}
	} aset_body;
}
