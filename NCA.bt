LittleEndian();
DisplayFormatHex();

local uint32 i, j, romfs_file_count;
local uint64 header_offset;

typedef enum <ubyte> {
	DistributionType_Download = 0,
	DistributionType_GameCard = 1
} DistributionType;

typedef enum <ubyte> {
	ContentType_Program    = 0,
	ContentType_Meta       = 1,
	ContentType_Control    = 2,
	ContentType_Manual     = 3,
	ContentType_Data       = 4,
	ContentType_PublicData = 5
} ContentType;

typedef enum <ubyte> {
	KeyAreaEncryptionKeyIndex_Application = 0,
	KeyAreaEncryptionKeyIndex_Ocean       = 1,
	KeyAreaEncryptionKeyIndex_System      = 2
} KeyAreaEncryptionKeyIndex;

typedef struct {
	uint32 start_block_offset; /* start_block_offset * 0x200, start_offset >> 9 */
	uint32 end_block_offset; /* end_block_offset * 0x200, end_offset >> 9 */
	ubyte  enable_entry;
	ubyte  reserved_1[0x7];
} FsEntry;

typedef struct {
	ubyte hash[0x20];
} FsHash;

typedef struct {
	ubyte key[0x10];
} EncryptedKey;

typedef enum <ubyte> {
	FormatType_RomFs       = 0,
	FormatType_PartitionFs = 1
} FormatType;

typedef enum <ubyte> {
	HashType_Auto                  = 0,
	HashType_None                  = 1,
	HashType_HierarchicalSha256    = 2,
	HashType_HierarchicalIntegrity = 3
} HashType;

typedef enum <ubyte> {
	EncryptionType_Auto     = 0,
	EncryptionType_None     = 1,
	EncryptionType_AesXts   = 2,
	EncryptionType_AesCtr   = 3,
	EncryptionType_AesCtrEx = 4
} EncryptionType;

typedef struct {
	ubyte  master_hash[0x20];
	uint32 hash_block_size;
	uint32 layer_count;
	uint64 hash_data_offset; /* Layer 1 */
	uint64 hash_data_size; /* Layer 1 */
	uint64 hash_target_offset; /* Layer 2 */
	uint64 hash_target_size; /* Layer 2 */
} HierarchicalSha256; /* Used for PartitionFs and NCA0 RomFs */

typedef enum <uint32> {
	TypeId_3DS    = 0x10000,
	TypeId_Switch = 0x20000
} TypeId;

typedef struct {
	uint64 hash_data_offset;
	uint64 hash_data_size;
	uint32 block_size; /* 1 << block_size, log2(hash_block_size) */
	uint32 reserved_1;
} HierarchicalIntegrityLayer;

typedef struct {
	char   magic[0x4];
	TypeId type_id;
	uint32 master_hash_size;
	uint32 layer_count;
	HierarchicalIntegrityLayer layers[layer_count - 1];
	ubyte  salt_source[0x20];
	ubyte  master_hash[master_hash_size];
} HierarchicalIntegrity;

typedef struct {
	if (hash_type == HashType_HierarchicalSha256) {
		HierarchicalSha256 hierarchical_sha256;
		ubyte reserved_1[0xB0];
	} else if (hash_type == HashType_HierarchicalIntegrity) {
		HierarchicalIntegrity hierarchical_integrity;
		ubyte reserved_1[0x18];
	} else {
		ubyte reserved_1[0xF8];
	}
} HashInfo;

typedef struct {
	char   magic[0x4];
	uint32 bucket_count;
	uint32 entry_count;
	uint32 reserved_1;
} BucketTreeHeader;

typedef struct {
	uint64 indirect_offset;
	uint64 indirect_size;
	BucketTreeHeader bucket_tree_header;
} IndirectHeader;

typedef struct {
	uint64 aes_ctr_ex_offset;
	uint64 aes_ctr_ex_size;
	BucketTreeHeader bucket_tree_header;
} AesCtrExHeader;

typedef struct {
	if (encryption_type == EncryptionType_AesCtrEx) {
		IndirectHeader indirect_header;
		AesCtrExHeader aes_ctr_ex_header;
	} else {
		ubyte reserved_1[0x40];
	}
} PatchInfo;

typedef struct {
	ubyte unknown_1[0x30]; /* Format unknown - If files are seen with this data, create an issue. */
} SparseInfo;

typedef struct {
	uint16 version;
	FormatType format_type;
	HashType hash_type;
	EncryptionType encryption_type;
	ubyte  reserved_1[0x3];
	HashInfo hash_info;
	PatchInfo patch_info;
	uint32 generation;
	uint32 secure_value; /* Program = 1 (nca_fs_headers[0]), 2 (nca_fs_headers[1]) - Manual = 4 (HtmlDocument), 5 (LegalInformation) */
	SparseInfo sparse_info;
	ubyte  reserved_2[0x88];
} NcaFsHeader;

struct {
	ubyte  main_signature[0x100];
	ubyte  npdm_signature[0x100];
	char   magic[0x4];
	if (magic != "NCA0" && magic != "NCA2" && magic != "NCA3") {
		Warning("File is not decrypted or is not a valid NCA file.");
		Exit(0);
	}
	DistributionType distribution_type;
	ContentType content_type;
	ubyte  key_generation_old; /* 0=1.0.0-2.3.0, 1=Unused, 2=3.0.0 */
	KeyAreaEncryptionKeyIndex key_area_encryption_key_index;
	uint64 content_size;
	uint64 program_id;
	uint32 content_index;
	uint32 sdk_addon_version;
	ubyte  key_generation; /* 3=3.0.1-3.0.2, 4=4.0.0-4.1.0, 5=5.0.0-5.1.0, 6=6.0.0-6.1.0, 7=6.2.0, 8=7.0.0-8.0.1, 9=8.1.0-8.1.1, 10=9.0.0-9.0.1, 11=9.1.0-9.2.0 */
	ubyte  main_signature_key_generation;
	ubyte  reserved_1[0xE];
	ubyte  rights_id[0x10];
	FsEntry fs_entries[4];
	FsHash fs_hashes[4];
	EncryptedKey encrypted_keys[16];
	NcaFsHeader nca_fs_headers[4] <optimize=false>;
} nca_header;

typedef struct {
	uint32 header_size;
	uint32 directory_hash_table_offset;
	uint32 directory_hash_table_size;
	uint32 directory_info_table_offset;
	uint32 directory_info_table_size;
	uint32 file_hash_table_offset;
	uint32 file_hash_table_size;
	uint32 file_info_table_offset;
	uint32 file_info_table_size;
	uint32 data_offset;
} RomFsHeader1;

typedef struct {
	uint64 header_size;
	uint64 directory_hash_table_offset;
	uint64 directory_hash_table_size;
	uint64 directory_info_table_offset;
	uint64 directory_info_table_size;
	uint64 file_hash_table_offset;
	uint64 file_hash_table_size;
	uint64 file_info_table_offset;
	uint64 file_info_table_size;
	uint64 data_offset;
} RomFsHeader2;

typedef struct {
	uint32 parent_directory_offset;
	uint32 sibling_directory_offset;
	uint32 child_directory_offset;
	uint32 child_file_offset;
	uint32 hash_offset;
	uint32 name_length; /* 0x300 Limit */
	char   name[name_length];
	ubyte  reserved_1[(name_length + 0x1B & -0x4) - (0x18 + name_length)];
} RomFsDirectoryInfo;

typedef struct {
	while (FTell() < header_offset + romfs_header.directory_info_table_offset + romfs_header.directory_info_table_size) {
		RomFsDirectoryInfo romfs_directory_info;
	}
} RomFsDirectoryInfoEntries;

typedef struct {
	uint32 parent_directory_offset;
	uint32 sibling_file_offset;
	uint64 data_offset;
	uint64 data_size;
	uint32 hash_offset;
	uint32 name_length; /* 0x300 Limit */
	char   name[name_length];
	ubyte  reserved_1[(name_length + 0x23 & -0x4) - (0x20 + name_length)];
} RomFsFileInfo;

typedef struct {
	while (FTell() < header_offset + romfs_header.file_info_table_offset + romfs_header.file_info_table_size) {
		RomFsFileInfo romfs_file_info;
		romfs_file_count++;
	}
} RomFsFileInfoEntries;

typedef struct {
	ubyte file[romfs_file_info_entries.romfs_file_info[i].data_size];
} RomFsFileDataEntry;

typedef struct {
	for (i = 0; i < romfs_file_count; i++) {
		RomFsFileDataEntry romfs_file_data_entry;
	}
} RomFsFileDataEntries;

typedef struct {
	uint64 data_offset;
	uint64 data_size;
	uint32 string_table_offset;
	uint32 reserved_1;
} PartitionFsFileEntry;

typedef struct {
	char   magic[0x4];
	uint32 file_count;
	uint32 string_table_size;
	uint32 reserved_1;
	PartitionFsFileEntry file_entries[file_count];
	char   string_table[string_table_size];
} PartitionFsHeader;

typedef struct {
	ubyte file[partition_fs_header.file_entries[j].data_size];
} PartitionFsFileDataEntry;

typedef struct {
	for (j = 0; j < partition_fs_header.file_count; j++) {
		PartitionFsFileDataEntry partition_fs_file_data_entry;
	}
} PartitionFsFileDataEntries;

typedef enum <uint32> {
	IndirectStorageIndex_Original = 0,
	IndirectStorageIndex_Patch    = 1
} IndirectStorageIndex;

typedef struct {
	uint64 virtual_offset;
	uint64 physical_offset;
	IndirectStorageIndex indirect_storage_index;
} IndirectStorageEntry;

typedef struct {
	uint32 index;
	uint32 entry_count;
	uint64 end_offset;
	IndirectStorageEntry indirect_storage_entry[0x3FF0 / 0x14];
	ubyte  reserved_1[0x3FF0 % 0x14];
} IndirectStorageBucket;

typedef struct {
	uint32 index;
	uint32 bucket_count;
	uint64 virtual_size;
	uint64 virtual_offsets[0x3FF0 / 0x8];
	IndirectStorageBucket indirect_storage_bucket[bucket_count];
} IndirectStorageBlock;

typedef struct {
	uint64 offset;
	uint32 size;
	uint32 generation;
} AesCtrExStorageEntry;

typedef struct {
	uint32 index;
	uint32 entry_count;
	uint64 end_offset;
	AesCtrExStorageEntry aes_ctr_ex_storage_entry[0x3FF];
} AesCtrExStorageBucket;

typedef struct {
	uint32 index;
	uint32 bucket_count;
	uint64 physical_size;
	uint64 physical_offsets[0x3FF0 / 0x8];
	AesCtrExStorageBucket aes_ctr_ex_storage_bucket[bucket_count];
} AesCtrExStorageBlock;

for (i = 0; i < 4; i++) {
	if (nca_header.fs_entries[i].enable_entry) {
		if (nca_header.nca_fs_headers[i].format_type == FormatType_RomFs && nca_header.nca_fs_headers[i].encryption_type != EncryptionType_AesCtrEx) {
			if (nca_header.magic == "NCA0") {
				header_offset = (nca_header.fs_entries[i].start_block_offset * 0x200) + nca_header.nca_fs_headers[i].hash_info.hierarchical_sha256.hash_target_offset;
				FSeek(header_offset);
				RomFsHeader1 romfs_header;
			} else {
				header_offset = (nca_header.fs_entries[i].start_block_offset * 0x200) + nca_header.nca_fs_headers[i].hash_info.hierarchical_integrity.layers[5].hash_data_offset;
				FSeek(header_offset);
				RomFsHeader2 romfs_header;
			}
			FSeek(header_offset + romfs_header.directory_hash_table_offset);
			uint32 romfs_directory_hash_entries[romfs_header.directory_hash_table_size / 0x4];
			RomFsDirectoryInfoEntries romfs_directory_info_entries;
			FSeek(header_offset + romfs_header.file_hash_table_offset);
			uint32 romfs_file_hash_entries[romfs_header.file_hash_table_size / 0x4];
			RomFsFileInfoEntries romfs_file_info_entries;
			FSeek(header_offset + romfs_header.data_offset);
			RomFsFileDataEntries romfs_file_data_entries;
		} else if (nca_header.nca_fs_headers[i].format_type == FormatType_PartitionFs && nca_header.nca_fs_headers[i].encryption_type != EncryptionType_AesCtrEx) {
			header_offset = (nca_header.fs_entries[i].start_block_offset * 0x200) + nca_header.nca_fs_headers[i].hash_info.hierarchical_sha256.hash_target_offset;
			FSeek(header_offset);
			PartitionFsHeader partition_fs_header;
			FSeek(header_offset + sizeof(partition_fs_header));
			PartitionFsFileDataEntries partition_fs_file_data_entries;
		} else if (nca_header.nca_fs_headers[i].format_type == FormatType_RomFs && nca_header.nca_fs_headers[i].encryption_type == EncryptionType_AesCtrEx) {
			FSeek((nca_header.fs_entries[i].start_block_offset * 0x200) + nca_header.nca_fs_headers[i].patch_info.indirect_header.indirect_offset);
			if (ReadUInt() != 0) break; /* Hactool incorrectly decrypts these sections when saving as plaintext, so abort if the data is wrong - use hactoolnet instead */
			IndirectStorageBlock indirect_storage_block;
			AesCtrExStorageBlock aes_ctr_ex_storage_block;
			/* TODO: Patch RomFs */
		}
	}
}
