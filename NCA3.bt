LittleEndian();
DisplayFormatHex();

typedef enum <ubyte> {
	DISTRIBUTION_DOWNLOAD,
	DISTRIBUTION_GAME_CARD
} distribution_type_t;

typedef enum <ubyte> {
	TYPE_PROGRAM,
	TYPE_META,
	TYPE_CONTROL,
	TYPE_MANUAL,
	TYPE_DATA,
	TYPE_PUBLIC_DATA,
	TYPE_INVALID = 0xFF
} content_type_t;

typedef enum <ubyte> {
	KAEK_INDEX_APPLICATION,
	KAEK_INDEX_OCEAN,
	KAEK_INDEX_SYSTEM
} kaek_index_t;

typedef enum <uint32> {
	ENTRY_NONE,
	ENTRY_EXISTS
} entry_flag_t;

struct {
	ubyte main_signature[0x100];
	ubyte npdm_signature[0x100];
	char magic[0x4];
	if (magic != "NCA3") {
		Warning("File is not decrypted.");
		Exit(-1);
	}
	distribution_type_t distribution_type;
	content_type_t content_type;
	ubyte old_key_generation; // 0/1=1.0.0-2.3.0, 2=3.0.0
	kaek_index_t key_area_encryption_key_index;
	uint64 content_size;
	uint64 program_id;
	uint32 content_index;
	uint32 sdk_addon_version;
	ubyte new_key_generation; // 3=3.0.1-3.0.2, 4=4.0.0-4.1.0, 5=5.0.0-5.1.0, 6=6.0.0-6.1.0, 7=6.2.0, 8=7.0.0-7.0.1, 9=8.1.0, A=9.0.0+, FF=Invalid
	ubyte padding_1[0xF];
	ubyte rights_id[0x10];
	struct {
		uint32 start_offset; // * 512
		uint32 end_offset; // * 512
		entry_flag_t entry_flag;
		uint32 padding_1;
	} fs_entries[4];
	struct {
		ubyte fs_hash[0x20];
	} fs_hashes[4];
	struct {
		ubyte encrypted_key[0x10];
	} encrypted_keys[16];
} nca3_header;

typedef enum <ubyte> {
	FORMAT_ROMFS,
	FORMAT_PFS0
} format_type_t;

typedef enum <ubyte> {
	HASH_AUTO, // Not valid
	HASH_NONE,
	HASH_HIERARCHICAL_SHA256,
	HASH_HIERARCHICAL_INTEGRITY
} hash_type_t;

typedef enum <ubyte> {
	ENCRYPTION_AUTO, // Not valid
	ENCRYPTION_NONE,
	ENCRYPTION_AES_XTS,
	ENCRYPTION_AES_CTR,
	ENCRYPTION_AES_CTR_EX
} encryption_type_t;

typedef struct {
	ubyte master_hash[0x20];
	uint32 hash_block_size;
	uint32 level_count;
	uint64 hash_data_offset;
	uint64 hash_data_size;
	uint64 hash_target_offset;
	uint64 hash_target_size;
} hierarchical_sha256_t;

typedef struct {
	char magic[0x4];
	uint32 version;
	uint32 master_hash_size;
	uint32 level_count;
	struct {
		uint64 hash_data_offset;
		uint64 hash_data_size;
		uint32 block_size; // 1 << block_size
		uint32 padding_1;
	} levels[level_count];
	ubyte padding_1[0x8];
	ubyte master_hash[0x20];
} hierarchical_integrity_t;

typedef struct {
	char magic[0x4];
	uint32 version;
	uint32 entry_count;
	uint32 padding_1;
} patch_info_t;

typedef struct {
	uint64 indirect_offset;
	uint64 indirect_size;
	patch_info_t patch_info;
} patch_info_indirect_header_t;

typedef struct {
	uint64 aes_ctr_ex_offset;
	uint64 aes_ctr_ex_size;
	patch_info_t patch_info;
} patch_info_aes_ctr_ex_header_t;

struct {
	uint16 version;
	format_type_t format_type;
	hash_type_t hash_type;
	encryption_type_t encryption_type;
	ubyte padding_1[0x3];
	if (hash_type == HASH_HIERARCHICAL_SHA256) {
		hierarchical_sha256_t hierarchical_sha256;
		ubyte padding_2[0xF0];
	} else if (hash_type == HASH_HIERARCHICAL_INTEGRITY) {
		hierarchical_integrity_t hierarchical_integrity;
		if (encryption_type == ENCRYPTION_AES_CTR_EX) {
			ubyte padding_2[0x18];
			patch_info_indirect_header_t patch_info_indirect_header;
			patch_info_aes_ctr_ex_header_t patch_info_aes_ctr_ex_header;
		} else {
			ubyte padding_2[0x58];
		}
	} else {
		ubyte padding_2[0x138];
	}
	uint32 generation;
	uint32 secure_value; // Program = 1 (nca_fs_header[0]), 2 (nca_fs_header[1]) - Manual = 4 (For HtmlDocument CNMT Content Type), 5 (For LegalInformation CNMT Content Type)
	ubyte padding_3[0xB8];
} nca_fs_header[4] <optimize=false>;

typedef struct {
	char magic[0x4];
	uint32 file_count;
	uint32 name_table_size;
	uint32 padding_1;
	struct {
		uint64 file_offset;
		uint64 file_size;
		uint32 name_table_offset;
		uint32 padding_1;
	} pfs0_file_entry[file_count];
	char name_table[name_table_size];
} pfs0_header_t;

typedef struct {
	uint64 header_size;
	uint64 directory_hash_table_offset;
	uint64 directory_hash_table_size;
	uint64 directory_entry_table_offset;
	uint64 directory_entry_table_size;
	uint64 file_hash_table_offset;
	uint64 file_hash_table_size;
	uint64 file_entry_table_offset;
	uint64 file_entry_table_size;
	uint64 data_offset;
} romfs_header_t;

typedef struct {
	uint32 parent_offset;
	uint32 sibling_offset;
	uint32 child_offset;
	uint32 file_offset;
	uint32 hash_offset;
	uint32 name_length; // 0x300 limit
	char name[name_length];
	ubyte padding_1[(name_length + 0x1B & -0x4) - (0x18 + name_length)];
} romfs_directory_entry_t;

typedef struct {
	uint32 parent_offset;
	uint32 sibling_offset;
	uint64 file_offset;
	uint64 file_size;
	uint32 hash_offset;
	uint32 name_length; // 0x300 limit
	char name[name_length];
	ubyte padding_1[(name_length + 0x23 & -0x4) - (0x20 + name_length)];
} romfs_file_entry_t;

local uint64 romfs_header_offset, pfs0_header_offset = 0;
local uint32 i, romfs_directory_hash_count, romfs_file_hash_count = 0;
for (i = 0; i < 4; i++) {
	if (nca_fs_header[i].format_type == FORMAT_ROMFS && nca_fs_header[i].hash_type == HASH_HIERARCHICAL_INTEGRITY && nca_fs_header[i].encryption_type != ENCRYPTION_AES_CTR_EX) {
		romfs_header_offset = (nca3_header.fs_entries[i].start_offset * 0x200) + nca_fs_header[i].hierarchical_integrity.levels[5].hash_data_offset;
		FSeek(romfs_header_offset);
		romfs_header_t romfs_header;
		romfs_directory_hash_count = romfs_header.directory_hash_table_size / 4;
		FSeek(romfs_header_offset + romfs_header.directory_hash_table_offset);
		uint32 romfs_directory_hash[romfs_directory_hash_count];
		FSeek(romfs_header_offset + romfs_header.directory_entry_table_offset);
		struct {
			while (FTell() < romfs_header_offset + romfs_header.directory_entry_table_offset + romfs_header.directory_entry_table_size) {
				romfs_directory_entry_t romfs_directory_entry;
			}
		} romfs_directory_entry_table;
		romfs_file_hash_count = romfs_header.file_hash_table_size / 4;
		FSeek(romfs_header_offset + romfs_header.file_hash_table_offset);
		uint32 romfs_file_hash[romfs_file_hash_count];
		FSeek(romfs_header_offset + romfs_header.file_entry_table_offset);
		struct {
			while (FTell() < romfs_header_offset + romfs_header.file_entry_table_offset + romfs_header.file_entry_table_size) {
				romfs_file_entry_t romfs_file_entry;
			}
		} romfs_file_entry_table;
	} else if (nca_fs_header[i].format_type == FORMAT_PFS0 && nca_fs_header[i].hash_type == HASH_HIERARCHICAL_SHA256 && nca_fs_header[i].encryption_type != ENCRYPTION_AES_CTR_EX) {
		pfs0_header_offset = (nca3_header.fs_entries[i].start_offset * 0x200) + nca_fs_header[i].hierarchical_sha256.hash_target_offset;
		FSeek(pfs0_header_offset);
		pfs0_header_t pfs0_header;
	}
}
