LittleEndian();
DisplayFormatHex();

typedef struct {
	uint32 Flags_TextCompress : 1;
	uint32 Flags_RoCompress   : 1;
	uint32 Flags_DataCompress : 1;
	uint32 Flags_TextHash     : 1;
	uint32 Flags_RoHash       : 1;
	uint32 Flags_DataHash     : 1;
} Flags;

typedef struct {
	uint32 file_offset;
	uint32 memory_offset;
	uint32 size;
} SegmentHeader;

typedef struct {
	uint32 offset;
	uint32 size;
} SectionHeader;

struct {
	char   magic[0x4];
	uint32 version;
	uint32 reserved_1;
	Flags  flags;
	SegmentHeader text_segment_header;
	uint32 module_name_offset;
	SegmentHeader ro_segment_header;
	uint32 module_name_size;
	SegmentHeader data_segment_header;
	uint32 bss_size;
	ubyte  module_id[0x20];
	uint32 text_file_size;
	uint32 ro_file_size;
	uint32 data_file_size;
	ubyte  reserved_2[0x1C];
	SectionHeader embedded_section_header; /* api_info */
	SectionHeader dyn_str_section_header;
	SectionHeader dyn_sym_section_header;
	ubyte  text_hash[0x20];
	ubyte  ro_hash[0x20];
	ubyte  data_hash[0x20];
} nso_header;

struct {
	FSeek(nso_header.text_segment_header.file_offset);
	ubyte text_segment[nso_header.text_file_size];
	FSeek(nso_header.ro_segment_header.file_offset);
	ubyte ro_segment[nso_header.ro_file_size];
	FSeek(nso_header.data_segment_header.file_offset);
	ubyte data_segment[nso_header.data_file_size];
} nso_body;

if (!nso_header.flags.Flags_TextCompress) {
	FSeek(nso_header.text_segment_header.file_offset);
	if (nso_header.module_name_offset == 0x100 && nso_header.module_name_size != 0) {
		struct {
			ubyte name_size;
			char  name[name_size];
		} module_name;
	}
	
	typedef struct {
		uint32 entry_point_insn;
		uint32 mod_offset;
	} RoCrt;
	
	struct {
		RoCrt ro_crt;
		if (ReadString(FTell(), 0x8) == "HOMEBREW") {
			char reserved_1[0x8];
		}
	} mod_start;
	
	FSeek(nso_header.text_segment_header.file_offset + mod_start.ro_crt.mod_offset);
	struct {
		char   magic[0x4];
		uint32 dynamic_offset;
		uint32 bss_start_offset;
		uint32 bss_end_offset;
		uint32 eh_frame_hdr_start_offset;
		uint32 eh_frame_hdr_end_offset;
		uint32 module_object_offset;
	} mod_header;
	
	if (exists(mod_start.reserved_1)) {
		struct {
			char   magic[0x4];
			uint32 got_start_offset;
			uint32 got_end_offset;
		} lny_header;
	}
}
